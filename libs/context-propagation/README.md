# context-propagation

A small library to make Context Propagation easier.

## Example Use Case

Say when you're logging, you want every log to have:
- The id of the user who made the request
- A "correlation id"
  - Some unique id that's the same for all logs that are triggered by a single API call
  - For example, for all logs generated by a single call to `POST /things`, the correlation id could be `9edfe071-b85d-44a7-9bce-a5553fcfdb44`, while for all logs generated by a subsequent call, the correlation id could be `138615f0-4faa-4d93-801c-57ca9acea4c0`

To do this, we could create a tiny library, like `@parker/log-context-propagation`, that is basically nothing but:

```ts
import { ContextPropagator } from '@parker/context-propagation'

export interface LogContext {
  correlationId: string
  userId?: string
}

export const LogContextPropagator = new ContextPropagator<LogContext>()
```

Then we just need to **set** the context in an appropriate place, and **read** it when we log. This is why putting it in a library is important - we may want to set the context in one app/library (e.g. a **NestJS** middleware library), and read the context in another app/library (e.g. a logging library). It's key that these reads and writes access the **same instance of `ContextPropagator`**, e.g. `LogContextPropagator` above, and it's much easier to share this singleton if `LogContextPropagator` is in a library.

An example of setting this context in **NestJS** middleware, so it gets set on every request our services receives:

```ts
import { Injectable, NestMiddleware } from '@nestjs/common'
import { LogContext, LogContextPropagator } from '@parker/log-context-propagation'
import { Request, Response, NextFunction } from 'express'
import { v4 as uuid } from 'uuid'

@Injectable()
export class LogContextMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const context: Context = {
      correlationId: uuid(),
      userId: getUserIdFromRequest(req)
    }
    LogContextPropagator.runWithContext(context, next)
  }
}
```

And then reading the context, so it's included in every log:

```ts
export class Logger {
  private underlyingLogger: MyUnderlyingLogger = ...

  public info(message: string, payload: object): void {
    this.underlyingLogger.info(message, {
      ...payload,
      context: LogContextPropagator.getContext(),
    })
  }
}
```

And that's it, we now have `correlationId` and `userId` magically set in all of our logs!

Extending this to **propagate context across web service calls** isn't hard, either. We would just need to:
- In our HTTP client library, before making an HTTP request, call `LogContextPropagator.getContext()`, and convert that context into headers that we set on the HTTP request
- Tweak our `LogContextMiddleware` above, so that instead of setting `correlationId` to be a new `uuid` every time, it instead uses the correlation id from the request header if it exists, else falls back to a new `uuid`

Now even if `serviceA` calls `serviceB`, which calls `serviceC`, the same `correlationId` set in `serviceA`'s middleware will be set in those downstream service calls (and thus their logs) too, making it easy to find all logs across all services that are associated with a single request.
