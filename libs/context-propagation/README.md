# context-propagation

A small library to make Context Propagation easier.

## Example Use Case

It's easiest to understand how this library works with an example. Say in logs generated by your web services, you want every log to have:
- The id of the user who made the request to the service
- A "correlation id"
  - Some unique id that's the same for all logs that are triggered by a single API call
  - For example, for all logs generated by a single call to `POST /things`, the correlation id could be `9edfe071-b85d-44a7-9bce-a5553fcfdb44`, while for all logs generated by a subsequent call, the correlation id could be `138615f0-4faa-4d93-801c-57ca9acea4c0`

To do this, we could create a tiny library, like `@parker/log-context-propagation`, that is basically nothing but:

```ts
import { ContextPropagator } from '@parker/context-propagation'

export interface LogContext {
  correlationId: string
  userId?: string
}

export const LogContextPropagator = new ContextPropagator<LogContext>()
```

Then we just need to **set** the context when our service receives an HTTP request, and **read** the context when we log. This is why putting it in a library is important - we may want to set the context in one app/library (e.g. a **NestJS** middleware library), and read the context in another app/library (e.g. a logging library). It's key that these reads and writes access the **same instance of `ContextPropagator`**, e.g. `LogContextPropagator` above, and it's much easier to share this singleton if `LogContextPropagator` is in a library.

An example of setting this context in **NestJS** middleware, so it gets set on every request our services receives:

```ts
import { Injectable, NestMiddleware } from '@nestjs/common'
import { LogContext, LogContextPropagator } from '@parker/log-context-propagation'
import { Request, Response, NextFunction } from 'express'
import { v4 as uuid } from 'uuid'

@Injectable()
export class LogContextMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const context: Context = {
      correlationId: uuid(),
      userId: getUserIdFromRequest(req)
    }
    LogContextPropagator.runWithContext(context, next)
  }
}
```

And then reading the context, so it's included in every log:

```ts
import { LogContextPropagator } from '@parker/log-context-propagation'
import { FooLogger } from 'foo-logger'

export class Logger {
  private underlyingLogger: FooLogger = new FooLogger()

  public info(message: string, payload: object): void {
    this.underlyingLogger.info(message, {
      ...payload,
      context: LogContextPropagator.getContext(),
    })
  }

  // And the same for other logging methods like debug, warn, error, etc.
}
```

And that's it, we now have `correlationId` and `userId` magically set in all of our logs!

However, this only propagates context **within** a service. For example, all logs in `serviceA` will have the same `correlationId` for a given HTTP request, but if `serviceA` calls `serviceB`, the `serviceB` logs will have a different `correlationId`, which isn't great - we'd like to be able to correlate logs across services too. Adding that functionality is easy though, we'd just need to:
- In our HTTP client library (that `serviceA` uses to call `serviceB`), before making an HTTP request, call `LogContextPropagator.getContext()`, and convert that context into headers that we set on the HTTP request
- Tweak our `LogContextMiddleware` above, so that instead of setting `correlationId` to be a new `uuid` every time, it instead uses the correlation id from the request header if it exists, else falls back to a new `uuid`

Now even if `serviceA` calls `serviceB`, which calls `serviceC`, as long as they're all using our context-aware logging, middleware and API client libs, the same `correlationId` set in `serviceA`'s middleware will be set in those downstream service calls (and thus their logs) too.
