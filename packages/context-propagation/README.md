# @parker/context-propagation

A small library to make Context Propagation easier.

## Example Use Case

It's easiest to understand how this library works with an example. Say in logs generated by your web services, you want every log to have:

- The id of the user who made the request to the service
- A "correlation id"
  - Some unique id that's the same for all logs that are triggered by a single API call
  - For example, for all logs generated by a single call to `POST /things`, the correlation id could be `9edfe071-b85d-44a7-9bce-a5553fcfdb44`, while for all logs generated by a subsequent call, the correlation id could be `138615f0-4faa-4d93-801c-57ca9acea4c0`

To do this, we could create a logging library, like `@parker/logging`, that defined log context, and adds it to logs:

```ts
import { ContextPropagator } from '@parker/context-propagation'
import { FooLogger } from 'foo-logger'

export interface LogContext {
  correlationId: string
  userId?: string
}

export const LogContextPropagator = new ContextPropagator<LogContext>()

export class Logger {
  private underlyingLogger: FooLogger = new FooLogger()

  public info(message: string, data: object): void {
    this.underlyingLogger.info(message, {
      data,
      context: LogContextPropagator.getContext(),
    })
  }

  // And the same for other logging methods like debug, warn, error, etc.
}
```

Then we just need to **set** the context when our service receives an HTTP request, and **read** the context when we log. This is why putting it in a library is important - we may want to set the context in one app/library (e.g. a **NestJS** middleware library), and read the context in another app/library (e.g. a logging library). It's key that these reads and writes access the **same instance of `ContextPropagator`**, e.g. `LogContextPropagator` above, and it's much easier to share this singleton if `LogContextPropagator` is in a library.

An example of setting this context in **NestJS** middleware, so it gets set on every request our services receives:

```ts
import { LogContextPropagator } from '@parker/logging'
import { NextFunction } from 'express'
import { v4 as uuid } from 'uuid'

export const logContextMiddleware = (request: Request, _response: Response, next: NextFunction): void => {
  LogContextPropagator.runWithContext(
    {
      correlationId: uuid(),
      userId: getUserIdFromRequest(request),
    },
    next
  )
}
```

And that's it, as long as we `logContextMiddleware` in our NestJS server, and use the `Logger` class for our logging, we now have `correlationId` and `userId` magically set in all of our logs!
